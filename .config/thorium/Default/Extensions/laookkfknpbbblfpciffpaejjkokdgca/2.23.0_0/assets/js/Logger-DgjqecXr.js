import{d as e,e as t}from"./array-YYQw31d9.js";async function s({method:e,url:t,data:s,headers:n}){const r=await fetch(t,{method:e,headers:n,body:"Object"===(null==s?void 0:s.constructor.name)?JSON.stringify(s):s}).catch((()=>({statusText:"No response from the server"}))),{status:a,headers:o,statusText:i}=r,c={status:a,headers:(null==o?void 0:o.entries)&&Object.fromEntries(o)||{},statusText:i};if(r.ok){const e=await r.text();return e&&(c.data=JSON.parse(e)),c}{let n="%c Request Error: "+(a||"");return i&&(n+=(a?" : ":"")+i),console.groupCollapsed(n,"color: #ff0505"),console.log("Request:",{method:e,url:t,data:s}),console.log("Response:",r),console.groupEnd(),c}}function n(e){return e>=200&&e<300}const r=e=>Object.entries(e),a=e=>Object.fromEntries(e),o=Object.freeze(Object.defineProperty({__proto__:null,entries:r,filterObject:(e,t)=>Object.fromEntries(Object.entries(e).filter((([,e])=>t(e)))),filterObjectKeysByObject:(e,t)=>Object.keys(t).reduce(((t,s)=>(t[s]=e[s],t)),{}),fromEntries:a,mergeObjects:(e,t)=>(e=e||{},Object.entries(t).forEach((([t,s])=>e[t]=s)),e)},Symbol.toStringTag,{value:"Module"})),i="store",c="_key",l="_value";function u(e){return void 0===e||"string"==typeof e||"object"==typeof(t=e)&&null!==t&&c in t&&l in t;var t}class h{constructor(e,t){this.name="keyValueDb:"+e,this.version=10*t,this.database=null}get db(){return this.database?Promise.resolve(this.database):this.open().then((e=>this.database=e))}open(){return new Promise(((e,t)=>{const s=indexedDB.open(this.name,this.version);s.onerror=()=>t(s.error),s.onupgradeneeded=()=>{s.result.createObjectStore(i,{keyPath:c})},s.onsuccess=()=>{const t=s.result;t.onversionchange=()=>{t.close(),this.database=null},e(t)}}))}async bulkPatch(t){return a(await e(r(t),(async([e,t])=>{if(!t)throw new Error("");return[e,await this.patch(e,t)]})))}async patch(e,t){const s=await this.get(e);if("object"!=typeof s)throw new Error(`KeyValueDb:${this.name} Error: patch called on ${typeof s} value. Patch may only be called on objects or empty rows. Key: ${e}, Existing Value: ${String(s)}`);const n=Object.assign({},s||{},t),r={[c]:e,[l]:n};return await this.transaction("readwrite",(e=>e.put(r))),{newValue:n,previousValue:s}}set(e,t){const s={[c]:e,[l]:t};return this.transaction("readwrite",(e=>e.put(s)))}delete(e){return this.transaction("readwrite",(t=>t.delete(e)))}async get(e){const t=await this.transaction("readonly",(t=>t.get(e)));return t?t[l]:null}async transaction(e,t,s={retries:3}){let n=0;return new Promise(((r,a)=>{const o=async()=>{try{const s=(await this.db).transaction([i],e);s.onerror=()=>a(n.error);const n=t(s.objectStore(i));n.onsuccess=()=>{const e=n.result;if(!u(e))throw new Error(`Transaction result does not match schema (does not contain a property matching ${c})`);r(e)}}catch(l){if(++n>s.retries)return void a(l);(await this.db).close(),this.database=null,o()}};o()}))}}const d=new h("misc",1);var g="2.23.0";class f{constructor(e){this.endpoint=e,this.config=null,this.pendingRequest=null}async getConfig(){return this.config||(this.pendingRequest?await this.pendingRequest:(this.pendingRequest=this.fetchWithLocalFallback(),this.config=await this.pendingRequest,this.config&&await d.set(this.endpoint,this.config))),this.config}fetchWithLocalFallback(){return s({method:"GET",data:void 0,url:"https://api.momentumdash.com/"+this.endpoint,headers:{"X-Momentum-Version":g}}).then((({data:e})=>{if(!e)throw"Request for config from API failed";return e})).catch((e=>(console.error(e),d.get(this.endpoint))))}}let p=new f("config");async function m(e){const s=await p.getConfig();return s?e?t(s,e):s:{}}const b="extension",w=new URL(`https://browser-http-intake.logs.datadoghq.com/v1/input/pub18ef9128dd80db1a80dfc3f9180b55b5?ddsource=browser&ddtags=${encodeURIComponent(`env:production,service:${b},version:2.23.0`)}`).toString();class y{constructor(e,t=1e-5){this.name=e,this.defaultSampleRate=t,this.sampleRate=null}warn(e,t){return this._log(e,t,"warn")}error(e,t){return this._log(e,t,"error")}info(e,t){return this._log(e,t,"info")}async _log(...e){if(!(await this._isEligibleForSubmission()))return;const[t,n,r]=this._parseArgs(e),a={status:r,date:Date.now(),service:b,message:t,_logger:this.name,...n};this.tabId&&(a.tabId=this.tabId),await s({method:"POST",url:w,data:a})}_convertUndefinedPropertiesToStrings(e){const t={};for(const[s,n]of Object.entries(e))t[s]=void 0===n?"<undefined>":n;return t}_parseArgs(e){let[t,s,n]=e;if(s||"object"!=typeof t||(s=t,t=s.message),s instanceof ErrorEvent&&(s=s.error),s instanceof Error){const{name:e,stack:t}=s;s={name:e,errorMessage:s.message,stack:t}}else"string"==typeof s?(t=`${t}: ${s}`,s={}):"string"==typeof t&&(null==s?void 0:s.message)&&(s.message=`${t}: ${s.message}`);return s&&(s=this._convertUndefinedPropertiesToStrings(s)),[t,s,n]}async _isEligibleForSubmission(){return null===this.sampleRate&&(this.sampleRate=await this._getSampleRate()),Math.random()<=this.sampleRate}async _getSampleRate(){const{datadogLoggingSamplingRate:e}=await m();return e?this.name.split(".").reduce(((t,s,n,r)=>{const a=r.slice(0,n+1).join(".");return a in e?e[a]:t}),this.defaultSampleRate):this.defaultSampleRate}}export{h as K,y as L,f as O,r as e,m as g,n as i,d as m,o,s as r};